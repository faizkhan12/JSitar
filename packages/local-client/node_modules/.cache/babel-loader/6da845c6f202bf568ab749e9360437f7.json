{"ast":null,"code":"import produce from \"immer\";\nimport { DELETE_CELL, INSERT_CELL_BEFORE, MOVE_CELL, UPDATE_CELL } from \"../action-types\";\nconst initialState = {\n  loading: false,\n  error: null,\n  order: [],\n  data: {}\n};\nconst cellsReducers = produce((state = initialState, action) => {\n  switch (action.type) {\n    case MOVE_CELL:\n      const {\n        direction\n      } = action.payload;\n      const index = state.order.findIndex(id => id === action.payload.id);\n      const targetIndex = direction === \"up\" ? index - 1 : index + 1;\n\n      if (targetIndex < 0 || targetIndex >= state.order.length - 1) {\n        return state;\n      }\n\n      state.order[index] = state.order[targetIndex];\n      state.order[targetIndex] = action.payload.id;\n      return state;\n\n    case UPDATE_CELL:\n      const {\n        id,\n        content\n      } = action.payload;\n      state.data[id].content = content;\n      return state;\n\n    case INSERT_CELL_BEFORE:\n      {\n        const cell = {\n          id: randomId(),\n          type: action.payload.type,\n          content: \"\"\n        };\n        state.data[cell.id] = cell;\n        const index = state.order.findIndex(id => id === action.payload.id); // if no index found then insert at the end\n\n        if (index < 0) {\n          state.order.push(cell.id);\n        } // otherwise insert before the current index\n        else {\n            state.order.splice(index, 0, cell.id);\n          }\n\n        return state;\n      }\n\n    case DELETE_CELL:\n      delete state.data[action.payload];\n      state.order = state.order.filter(id => id !== action.payload);\n      return state;\n\n    default:\n      return state;\n  }\n}, initialState); // fn to random generation id\n\nconst randomId = () => {\n  return Math.random().toString(36).substr(2, 5);\n};\n\nexport default cellsReducers;","map":{"version":3,"sources":["/home/faiz/react-tutorial/readme-generator/src/redux/reducers/cellsReducers.ts"],"names":["produce","DELETE_CELL","INSERT_CELL_BEFORE","MOVE_CELL","UPDATE_CELL","initialState","loading","error","order","data","cellsReducers","state","action","type","direction","payload","index","findIndex","id","targetIndex","length","content","cell","randomId","push","splice","filter","Math","random","toString","substr"],"mappings":"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","sourcesContent":["import produce from \"immer\"\nimport {\n  DELETE_CELL,\n  INSERT_CELL_BEFORE,\n  MOVE_CELL,\n  UPDATE_CELL,\n} from \"../action-types\"\nimport { Action } from \"../actions\"\nimport { Cell } from \"../cell\"\n\ninterface CellsState {\n  data: {\n    [key: string]: Cell\n  }\n  loading: boolean\n  error: string | null\n  order: string[]\n}\n\nconst initialState: CellsState = {\n  loading: false,\n  error: null,\n  order: [],\n  data: {},\n}\n\nconst cellsReducers = produce(\n  (state: CellsState = initialState, action: Action): CellsState | void => {\n    switch (action.type) {\n      case MOVE_CELL:\n        const { direction } = action.payload\n        const index = state.order.findIndex((id) => id === action.payload.id)\n        const targetIndex = direction === \"up\" ? index - 1 : index + 1\n\n        if (targetIndex < 0 || targetIndex >= state.order.length - 1) {\n          return state\n        }\n\n        state.order[index] = state.order[targetIndex]\n        state.order[targetIndex] = action.payload.id\n\n        return state\n\n      case UPDATE_CELL:\n        const { id, content } = action.payload\n        state.data[id].content = content\n\n        return state\n\n      case INSERT_CELL_BEFORE: {\n        const cell: Cell = {\n          id: randomId(),\n          type: action.payload.type,\n          content: \"\",\n        }\n        state.data[cell.id] = cell\n        const index = state.order.findIndex((id) => id === action.payload.id)\n        // if no index found then insert at the end\n        if (index < 0) {\n          state.order.push(cell.id)\n        }\n        // otherwise insert before the current index\n        else {\n          state.order.splice(index, 0, cell.id)\n        }\n\n        return state\n      }\n\n      case DELETE_CELL:\n        delete state.data[action.payload]\n        state.order = state.order.filter((id) => id !== action.payload)\n\n        return state\n\n      default:\n        return state\n    }\n  },\n  initialState\n)\n\n// fn to random generation id\nconst randomId = () => {\n  return Math.random().toString(36).substr(2, 5)\n}\n\nexport default cellsReducers\n"]},"metadata":{},"sourceType":"module"}